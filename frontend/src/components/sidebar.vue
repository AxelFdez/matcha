<template>
  <aside
    id="default-sidebar"
    class="fixed right-0 top-20 z-50 h-screen w-64 -translate-x-full transition-transform sm:translate-x-0"
    aria-label="Sidenav"
  >
    <div class="h-full overflow-y-auto border-r border-gray-900 bg-zinc-900 px-3 py-5">
      <!-- Main Sidebar Content -->
      <div
        class="mb-4 flex items-center justify-around border-b border-gray-200 pb-4 dark:border-gray-600"
      >
        <ProfileBtn v-if="$store.getters.getIsConnected" @click="closeSidebar" />
        <DisconnectBtn v-if="$store.getters.getIsConnected" @click="closeSidebar" />
      </div>

      <div v-if="!showNotifications && !showChat">
        <ul class="space-y-2">
          <li>
            <button
              @click="openNotifications"
              class="group flex w-full items-center rounded-lg p-2 text-base font-normal text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700"
            >
              <svg
                class="size-6 text-gray-400 transition duration-75 group-hover:text-gray-900 dark:text-gray-400 dark:group-hover:text-white"
                fill="currentColor"
                viewBox="0 0 20 20"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  d="M10 2a6 6 0 00-6 6v3.586l-.707.707A1 1 0 004 14h12a1 1 0 00.707-1.707L16 11.586V8a6 6 0 00-6-6zM10 18a3 3 0 01-3-3h6a3 3 0 01-3 3z"
                ></path>
              </svg>
              <span class="ml-3 flex-1 text-left">Notifications</span>
              <span
                v-if="notificationCount > 0"
                class="inline-flex h-5 w-5 items-center justify-center rounded-full bg-red-500 text-xs font-semibold text-white animate-pulse"
              >
                {{ notificationCount > 99 ? "99+" : notificationCount }}
              </span>
            </button>
          </li>
          <li>
            <button
              @click="openChat"
              class="group flex w-full items-center rounded-lg p-2 text-base font-normal text-gray-900 hover:bg-gray-100 dark:text-white dark:hover:bg-gray-700"
            >
              <svg
                class="size-6 text-gray-400 transition duration-75 group-hover:text-gray-900 dark:text-gray-400 dark:group-hover:text-white"
                fill="currentColor"
                viewBox="0 0 20 20"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path d="M2 5A2 2 0 014 3h12a2 2 0 012 2v8a2 2 0 01-2 2H7l-3 3V5z"></path>
              </svg>
              <span class="ml-3 flex-1 text-left">Chat</span>
              <span
                v-if="unreadMessagesCount > 0"
                class="inline-flex h-5 w-5 items-center justify-center rounded-full bg-blue-500 text-xs font-semibold text-white animate-pulse"
              >
                {{ unreadMessagesCount > 99 ? "99+" : unreadMessagesCount }}
              </span>
            </button>
          </li>
        </ul>
      </div>

      <!-- Notifications Content -->
      <div v-if="showNotifications">
        <div class="mb-4 flex items-center">
          <button
            @click="backToMain"
            class="mr-3 rounded-lg p-2 text-gray-500 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700"
          >
            <svg
              class="size-5"
              fill="currentColor"
              viewBox="0 0 20 20"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                fill-rule="evenodd"
                d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z"
                clip-rule="evenodd"
              ></path>
            </svg>
          </button>
          <h2 class="text-lg font-semibold text-gray-900 dark:text-white">Notifications</h2>
        </div>

        <!-- Notifications List -->
        <div class="space-y-2">
          <div
            v-if="notifications.length === 0"
            class="rounded-lg p-4 text-center text-gray-500 dark:text-gray-400"
          >
            Aucune notification
          </div>

          <div
            v-for="notification in notifications"
            :key="notification.id"
            class="rounded-lg border border-gray-200 bg-white p-3 shadow-sm dark:border-gray-600 dark:bg-gray-700 transition-all"
            :class="{
              'border-l-4 border-l-blue-500 animate-slideIn': !notification.viewed,
              'opacity-75': notification.viewed,
            }"
          >
            <div class="flex items-start justify-between">
              <div class="flex-1">
                <!-- Ic√¥ne selon le type -->
                <div class="flex items-center gap-2 mb-1">
                  <span v-if="notification.type === 'like'" class="text-red-500">‚ù§Ô∏è</span>
                  <span v-else-if="notification.type === 'match'" class="text-pink-500">üíï</span>
                  <span v-else-if="notification.type === 'unlike'" class="text-gray-500">üíî</span>
                  <span v-else-if="notification.type === 'profile_view'" class="text-blue-500"
                    >üëÅÔ∏è</span
                  >
                  <span v-else-if="notification.type === 'message'" class="text-green-500">üí¨</span>

                  <p class="text-sm font-medium text-gray-900 dark:text-white">
                    {{ notification.title }}
                  </p>
                </div>

                <p
                  v-if="notification.message"
                  class="mt-1 text-sm text-gray-600 dark:text-gray-300"
                >
                  {{ notification.message }}
                </p>
                <p class="mt-1 text-xs text-gray-400 dark:text-gray-500">
                  {{ formatDate(notification.createdAt) }}
                </p>
              </div>
              <button
                @click="deleteNotification(notification.id)"
                class="ml-2 rounded p-1 text-gray-400 hover:bg-gray-100 hover:text-gray-600 dark:hover:bg-gray-600 dark:hover:text-gray-300"
              >
                <svg class="size-4" fill="currentColor" viewBox="0 0 20 20">
                  <path
                    fill-rule="evenodd"
                    d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z"
                    clip-rule="evenodd"
                  ></path>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Chat Content -->
      <div v-if="showChat && !showChatMessages">
        <div class="mb-4 flex items-center">
          <button
            @click="backToMain"
            class="mr-3 rounded-lg p-2 text-gray-500 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700"
          >
            <svg
              class="size-5"
              fill="currentColor"
              viewBox="0 0 20 20"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                fill-rule="evenodd"
                d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z"
                clip-rule="evenodd"
              ></path>
            </svg>
          </button>
          <h2 class="text-lg font-semibold text-gray-900 dark:text-white">Chat</h2>
        </div>

        <!-- Conversations List -->
        <div class="space-y-2">
          <div
            v-if="chatLoading"
            class="rounded-lg p-4 text-center text-gray-500 dark:text-gray-400"
          >
            Chargement...
          </div>

          <div
            v-else-if="conversations.length === 0"
            class="rounded-lg p-4 text-center text-gray-500 dark:text-gray-400"
          >
            Aucune conversation
          </div>

          <div
            v-for="conversation in conversations"
            :key="conversation.id"
            @click="openChatMessages(conversation)"
            class="cursor-pointer rounded-lg border border-gray-200 bg-white p-3 shadow-sm hover:bg-gray-50 dark:border-gray-600 dark:bg-gray-700 dark:hover:bg-gray-600"
            :class="{ 'border-l-4 border-l-blue-500': conversation.hasUnreadMessages }"
          >
            <div class="flex items-center justify-between">
              <div class="flex items-center space-x-3">
                <div class="size-10 flex-shrink-0">
                  <img
                    v-if="getFirstPhoto(conversation.otherUser.photos)"
                    :src="getFirstPhoto(conversation.otherUser.photos)"
                    :alt="conversation.otherUser.username"
                    class="size-10 rounded-full object-cover"
                  />
                  <div
                    v-else
                    class="size-10 rounded-full bg-gray-300 flex items-center justify-center text-gray-600 dark:bg-gray-600 dark:text-gray-300"
                  >
                    {{ conversation.otherUser.username.charAt(0).toUpperCase() }}
                  </div>
                </div>
                <div class="min-w-0 flex-1">
                  <p class="text-sm font-medium text-gray-900 dark:text-white">
                    {{ conversation.otherUser.username }}
                  </p>
                  <p
                    v-if="conversation.lastMessage"
                    class="text-sm text-gray-600 dark:text-gray-300 truncate"
                  >
                    {{ conversation.lastMessage.message }}
                  </p>
                  <p v-else class="text-sm text-gray-400 dark:text-gray-500 italic">
                    Commencer une conversation
                  </p>
                </div>
              </div>
              <div class="flex flex-col items-end space-y-1">
                <p v-if="conversation.lastMessage" class="text-xs text-gray-400 dark:text-gray-500">
                  {{ formatDate(conversation.lastMessage.date) }}
                </p>
                <span
                  v-if="conversation.unreadCount > 0"
                  class="inline-flex h-5 w-5 items-center justify-center rounded-full bg-blue-500 text-xs font-semibold text-white"
                >
                  {{ conversation.unreadCount }}
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Chat Messages View -->
      <div v-if="showChatMessages && selectedConversation">
        <div class="mb-4 flex items-center">
          <button
            @click="backToConversations"
            class="mr-3 rounded-lg p-2 text-gray-500 hover:bg-gray-100 dark:text-gray-400 dark:hover:bg-gray-700"
          >
            <svg
              class="size-5"
              fill="currentColor"
              viewBox="0 0 20 20"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                fill-rule="evenodd"
                d="M9.707 16.707a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414l6-6a1 1 0 011.414 1.414L5.414 9H17a1 1 0 110 2H5.414l4.293 4.293a1 1 0 010 1.414z"
                clip-rule="evenodd"
              ></path>
            </svg>
          </button>
          <div class="flex items-center space-x-2">
            <div class="size-8 flex-shrink-0">
              <img
                v-if="getFirstPhoto(selectedConversation.otherUser.photos)"
                :src="getFirstPhoto(selectedConversation.otherUser.photos)"
                :alt="selectedConversation.otherUser.username"
                class="size-8 rounded-full object-cover"
              />
              <div
                v-else
                class="size-8 rounded-full bg-gray-300 flex items-center justify-center text-gray-600 dark:bg-gray-600 dark:text-gray-300 text-xs"
              >
                {{ selectedConversation.otherUser.username.charAt(0).toUpperCase() }}
              </div>
            </div>
            <h2 class="text-lg font-semibold text-gray-900 dark:text-white">
              {{ selectedConversation.otherUser.username }}
            </h2>
          </div>
        </div>

        <!-- Messages Container -->
        <div class="flex h-96 flex-col">
          <!-- Messages List -->
          <div
            ref="messagesContainer"
            class="flex-1 space-y-3 overflow-y-auto pr-2 pb-4"
            style="max-height: 320px"
          >
            <div v-if="messagesLoading" class="flex justify-center items-center h-full">
              <p class="text-gray-500 dark:text-gray-400">Chargement des messages...</p>
            </div>

            <div v-else-if="messages.length === 0" class="flex justify-center items-center h-full">
              <p class="text-gray-500 dark:text-gray-400">Aucun message pour le moment</p>
            </div>

            <div
              v-for="message in messages"
              :key="message.id || message.date"
              class="flex"
              :class="message.sender === currentUserId ? 'justify-end' : 'justify-start'"
            >
              <div
                class="max-w-xs lg:max-w-md px-3 py-2 rounded-lg text-sm"
                :class="
                  message.sender === currentUserId
                    ? 'bg-blue-500 text-white rounded-br-none'
                    : 'bg-gray-200 text-gray-900 dark:bg-gray-600 dark:text-white rounded-bl-none'
                "
              >
                <p>{{ message.message }}</p>
                <p class="text-xs opacity-75 mt-1">
                  {{ formatMessageTime(message.date) }}
                </p>
              </div>
            </div>
          </div>

          <!-- Message Input -->
          <div class="border-t border-gray-200 dark:border-gray-600 pt-4">
            <div class="flex items-center space-x-2">
              <input
                v-model="newMessage"
                @keyup.enter="sendMessage"
                :disabled="sendingMessage"
                type="text"
                placeholder="Tapez votre message..."
                class="flex-1 rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-50 dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-500 dark:focus:border-blue-400"
              />

              <button
                @click="sendMessage"
                :disabled="!newMessage.trim() || sendingMessage"
                class="rounded-lg bg-blue-500 px-4 py-2 text-sm font-medium text-white hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-blue-600 dark:hover:bg-blue-700"
              >
                <svg
                  v-if="sendingMessage"
                  class="size-4 animate-spin"
                  fill="none"
                  viewBox="0 0 24 24"
                >
                  <circle
                    class="opacity-25"
                    cx="12"
                    cy="12"
                    r="10"
                    stroke="currentColor"
                    stroke-width="4"
                  ></circle>
                  <path
                    class="opacity-75"
                    fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  ></path>
                </svg>
                <svg v-else class="size-4" fill="currentColor" viewBox="0 0 20 20">
                  <path
                    d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"
                  ></path>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </aside>
</template>

<script>
import { ref, computed, onMounted, onUnmounted, nextTick } from "vue";
import { fetchData } from "../config/api.js";
import { useStore } from "vuex";
import DisconnectBtn from "./header/DisconnectBtn.vue";
import ProfileBtn from "./header/ProfileBtn.vue";

export default {
  name: "Sidebar",
  components: {
    ProfileBtn,
    DisconnectBtn,
  },
  emits: ["close"],
  setup(props, { emit }) {
    const store = useStore();

    // Close sidebar function
    const closeSidebar = () => {
      emit("close");
    };

    // Notifications
    const showNotifications = ref(false);
    const notifications = ref([]);
    const loading = ref(false);

    // Chat
    const showChat = ref(false);
    const showChatMessages = ref(false);
    const conversations = ref([]);
    const selectedConversation = ref(null);
    const messages = ref([]);
    const newMessage = ref("");
    const chatLoading = ref(false);
    const messagesLoading = ref(false);
    const sendingMessage = ref(false);
    const messagesContainer = ref(null);

    // Polling interval
    let pollingInterval = null;
    let newNotificationTimeout = null;

    // Utility function to get first photo
    const getFirstPhoto = (photos) => {
      if (!photos || !Array.isArray(photos)) return null;

      const firstPhoto = photos.find(photo => photo);
      if (!firstPhoto) return null;

      return `http://localhost:3000${firstPhoto.replace("/app", "")}`;
    };

    // Computed properties
    const notificationCount = computed(() => {
      return notifications.value.filter((n) => !n.viewed).length;
    });

    const unreadMessagesCount = computed(() => {
      return conversations.value.reduce((count, conv) => count + (conv.unreadCount || 0), 0);
    });

    const currentUserId = computed(() => {
      return localStorage.getItem("userId");
    });

    // Navigation functions
    const openNotifications = async () => {
      showNotifications.value = true;
      showChat.value = false;
      showChatMessages.value = false;
      await fetchNotifications();
      await markNotificationsAsViewed();
    };

    const openChat = async () => {
      showChat.value = true;
      showNotifications.value = false;
      showChatMessages.value = false;
      await fetchConversations();
    };

    const openChatMessages = async (conversation) => {
      selectedConversation.value = conversation;
      showChatMessages.value = true;
      await fetchMessages(conversation);

      // Marquer les messages comme lus
      conversation.unreadCount = 0;
      conversation.hasUnreadMessages = false;

      scrollToBottom();
    };

    const backToMain = () => {
      showNotifications.value = false;
      showChat.value = false;
      showChatMessages.value = false;
      selectedConversation.value = null;
    };

    const backToConversations = () => {
      showChatMessages.value = false;
      selectedConversation.value = null;
    };

    const fetchNotifications = async () => {
      if (loading.value) return;

      loading.value = true;
      try {
        const response = await fetchData("/notifications", {
          method: "GET",
        });
        notifications.value = response.data || [];
      } catch (error) {
        console.error("Erreur lors du chargement des notifications:", error);
        notifications.value = [];
      } finally {
        loading.value = false;
      }
    };

    const markNotificationsAsViewed = async () => {
      try {
        const ws = store.getters.getWebSocket;
        const userId = localStorage.getItem("userId");

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "notification",
              userId: userId,
            })
          );

          // Mettre √† jour l'√©tat local
          notifications.value = notifications.value.map((n) => ({ ...n, viewed: true }));
        }
      } catch (error) {
        console.error("Erreur lors du marquage des notifications:", error);
      }
    };

    const deleteNotification = async (notificationId) => {
      try {
        await fetchData(`/notifications/${notificationId}`, { method: "DELETE" });
        notifications.value = notifications.value.filter((n) => n.id !== notificationId);
      } catch (error) {
        console.error("Erreur lors de la suppression de la notification:", error);
      }
    };

    // Chat functions
    const fetchConversations = async () => {
      if (chatLoading.value) return;

      chatLoading.value = true;
      try {
        const response = await fetchData("/conversations", {
          method: "GET",
        });

        if (response.response.ok && response.data && response.data.conversations) {
          conversations.value = response.data.conversations;
        } else {
          conversations.value = [];
        }
      } catch (error) {
        console.error("Erreur lors du chargement des conversations:", error);
        conversations.value = [];
      } finally {
        chatLoading.value = false;
      }
    };

    const fetchMessages = async (conversation) => {
      if (messagesLoading.value) return;

      messagesLoading.value = true;
      try {
        const response = await fetchData(`/conversations/${conversation.id}/messages`, {
          method: "GET",
        });

        if (response.response.ok && response.data && response.data.messages) {
          messages.value = response.data.messages;
        } else {
          messages.value = [];
        }
      } catch (error) {
        console.error("Erreur lors du chargement des messages:", error);
        messages.value = [];
      } finally {
        messagesLoading.value = false;
      }
    };

    const sendMessage = async () => {
      if (!newMessage.value.trim() || sendingMessage.value || !selectedConversation.value) return;

      const messageText = newMessage.value.trim();
      const tempMessage = {
        id: Date.now().toString(),
        sender: currentUserId.value,
        message: messageText,
        date: new Date(),
        temp: true,
      };

      messages.value.push(tempMessage);
      newMessage.value = "";
      scrollToBottom();

      sendingMessage.value = true;

      try {
        const ws = store.getters.getWebSocket;
        const userId = localStorage.getItem("userId");

        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "chat",
              userId: userId,
              message: {
                UserRecipient: selectedConversation.value.otherUser.username,
                message: messageText,
              },
            })
          );

          const messageIndex = messages.value.findIndex((m) => m.id === tempMessage.id);
          if (messageIndex !== -1) {
            messages.value[messageIndex].temp = false;
          }
        } else {
          throw new Error("WebSocket connection not available");
        }
      } catch (error) {
        console.error("Erreur lors de l'envoi du message:", error);
        messages.value = messages.value.filter((m) => m.id !== tempMessage.id);
      } finally {
        sendingMessage.value = false;
      }
    };

    const scrollToBottom = async () => {
      await nextTick();
      if (messagesContainer.value) {
        messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight;
      }
    };

    const handleIncomingMessage = async (messageData) => {
      if (messageData.type !== "chat") return;

      const newMsg = {
        id: messageData.message.id || Date.now().toString(),
        sender: messageData.message.sender,
        message: messageData.message.message,
        date: new Date(messageData.message.date),
        senderUsername: messageData.message.sender_username,
      };

      const convActive =
        selectedConversation.value &&
        (messageData.message.sender === selectedConversation.value.otherUser.id.toString() ||
          messageData.message.sender_username === selectedConversation.value.otherUser.username);

      if (convActive) {
        // Ajouter le message dans l'UI
        messages.value.push(newMsg);
        scrollToBottom();

        // Appeler ton endpoint pour marquer comme lu c√¥t√© serveur
        try {
          await fetchData(`/conversations/${selectedConversation.value.id}/messages`, {
            method: "GET", // GET dans ton code existant d√©clenche d√©j√† le UPDATE read_at
          });
        } catch (error) {
          console.error("Erreur lors du marquage des messages comme lus :", error);
        }
      } else {
        // Conversation inactive : incr√©menter unreadCount
        const conversationIndex = conversations.value.findIndex(
          (conv) =>
            conv.otherUser.id.toString() === messageData.message.sender ||
            conv.otherUser.username === messageData.message.sender_username
        );

        if (conversationIndex !== -1) {
          conversations.value[conversationIndex].lastMessage = {
            id: newMsg.id,
            message: newMsg.message,
            sender: newMsg.sender,
            date: newMsg.date,
          };
          conversations.value[conversationIndex].unreadCount =
            (conversations.value[conversationIndex].unreadCount || 0) + 1;
          conversations.value[conversationIndex].hasUnreadMessages = true;
        }

        // Notification navigateur
        if (Notification.permission === "granted") {
          new Notification(`Nouveau message de ${newMsg.senderUsername}`, {
            body: newMsg.message,
            icon: "/icon-notification.png",
          });
        }
      }
    };

    const handleIncomingNotification = (data) => {
      let notif;

      if (data.notification) {
        notif = data.notification;
      } else {
        notif = data;
      }

      // Ajouter la notification avec le type
      const newNotification = {
        id: notif.id || Date.now(),
        type: notif.type || "default", // like, match, unlike, profile_view, message
        title: notif.title,
        message: notif.message,
        createdAt: notif.createdAt || new Date().toISOString(),
        viewed: false,
      };

      notifications.value.unshift(newNotification);

      // Afficher une notification navigateur si permission accord√©e
      if (Notification.permission === "granted") {
        new Notification(newNotification.title, {
          body: newNotification.message,
          icon: "/icon-notification.png",
          tag: newNotification.id.toString(),
        });
      }
    };

    // Polling pour les notifications (backup au cas o√π WebSocket rate)
    const startPolling = () => {
      // V√©rifier les nouvelles notifications toutes les 10 secondes
      pollingInterval = setInterval(async () => {
        if (!showNotifications.value) {
          await fetchNotifications();
        }
        if (!showChat.value) {
          await fetchConversations();
        }
      }, 10000); // 10 secondes
    };

    const stopPolling = () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
      }
      if (newNotificationTimeout) {
        clearTimeout(newNotificationTimeout);
        newNotificationTimeout = null;
      }
    };

    // Demander la permission pour les notifications navigateur
    const requestNotificationPermission = async () => {
      if ("Notification" in window && Notification.permission === "default") {
        await Notification.requestPermission();
      }
    };

    onMounted(async () => {
      // Demander permission notifications
      await requestNotificationPermission();

      // Fetch initial notifications
      await fetchNotifications();
      await fetchConversations();

      // D√©marrer le polling
      startPolling();

      // Setup WebSocket
      const ws = store.getters.getWebSocket;
      if (ws) {
        const originalOnMessage = ws.onmessage;
        ws.onmessage = function (messageEvent) {
          if (originalOnMessage) originalOnMessage.call(this, messageEvent);

          try {
            const data = JSON.parse(messageEvent.data);

            // Gestion des notifications (like, match, unlike, profile_view)
            if (
              data.type === "notification" ||
              data.type === "like" ||
              data.type === "match" ||
              data.type === "unlike" ||
              data.type === "profile_view"
            ) {
              handleIncomingNotification(data);
            }

            // Gestion des messages chat
            if (data.type === "chat" && data.message) {
              handleIncomingMessage(data);
            }
          } catch (e) {
            console.error("Error parsing WS message:", e);
          }
        };
      }
    });

    onUnmounted(() => {
      stopPolling();
    });

    // Utility functions
    const formatDate = (dateString) => {
      if (!dateString) return "";
      const date = new Date(dateString);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return "√Ä l'instant";
      if (diffMins < 60) return `Il y a ${diffMins}min`;
      if (diffHours < 24) return `Il y a ${diffHours}h`;
      if (diffDays < 7) return `Il y a ${diffDays}j`;
      return date.toLocaleDateString("fr-FR");
    };

    const formatMessageTime = (dateString) => {
      if (!dateString) return "";
      const date = new Date(dateString);
      const now = new Date();
      const diffHours = Math.floor((now - date) / 3600000);

      if (diffHours < 24) {
        return date.toLocaleTimeString("fr-FR", { hour: "2-digit", minute: "2-digit" });
      } else {
        return date.toLocaleDateString("fr-FR", { day: "2-digit", month: "2-digit" });
      }
    };

    // Return all reactive references and functions
    return {
      closeSidebar,
      showNotifications,
      notifications,
      loading,
      showChat,
      showChatMessages,
      conversations,
      selectedConversation,
      messages,
      newMessage,
      chatLoading,
      messagesLoading,
      sendingMessage,
      messagesContainer,
      notificationCount,
      unreadMessagesCount,
      currentUserId,
      openNotifications,
      openChat,
      openChatMessages,
      backToMain,
      backToConversations,
      deleteNotification,
      sendMessage,
      formatDate,
      formatMessageTime,
      getFirstPhoto,
    };
  },
};
</script>

<style scoped>
@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.animate-slideIn {
  animation: slideIn 0.3s ease-out;
}
</style>
